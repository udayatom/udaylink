# ROADMAP TO LEARNING DATA STRUCTURES AND ALGORITHMS (DSA)

![](https://miro.medium.com/max/1400/1*Ym2ZjsFm8Y-x4NBPzpBu5Q.png)

Source: FreeEducationWeb

Data Structures and Algorithms are at the base of almost every application we code, every project we create. Interviews for developers involve DSA as it helps test logic and problem-solving skills of the candidate. In recent years, there has been an enormous growth in the number of competitive programming websites and courses provided in DSA. Before we dive into understanding the roadmap, let’s learn what exactly DSA is and why is it important.

# **WHAT IS DATA STRUCTURES AND ALGORITHMS?**

![](https://miro.medium.com/max/1200/1*U63ctzixH5ZLfY64iJlTdg.png)

Source: AllFreeSewing

Imagine having sequins of different colours mixed after a long sewing session. You need to organize them based on colours so that you don’t face any difficulty in your next sewing session. These containers can be thought of as data structures where different kinds of sequins (data) are stored based on predefined criteria to ease solving problems.

A data structure is a named location where data and information are stored and organized based on the associated operations in order to increase the efficiency of programming. Algorithms consist of ordered steps to solve a particular problem or achieve a goal. Learning data structures and their algorithms is essential to create clean and optimized code.

# GETTING STARTED WITH THE BASICS

Whichever language that you select, you need to be thorough with the syntax and know the data structures that the language provides. There are several primitive and non-primitive data structures that you should be aware of and learn how to code them.

![[Screenshot 2022-08-17 at 5.13.51 PM.png)

Source: TutorialLink

Learning and mastering these isn’t as tough as it seems to be. You need to strengthen your logic and not mug up the code as it is. Follow the 3 steps to be stronger at your fundamentals:

1.  Read
2.  Visualize by drawing
3.  Understand and Code

Often people think drawing and paper-pen practice as a waste of time but when you learn data structures, this tends to be the best way to strengthen logic. You might have to spend a lot of time in solving problems during the first few days. However, it will seem much easier once you get used to solving similar problems.

One of the most common applications of data structures is Search and Sort algorithms. These come in handy not only in programming but even in day-to-day life. The most commonly used of these are:

1.  Binary Search
2.  Search an element in a sorted and rotated array
3.  Bubble Sort
4.  Selection Sort
5.  Insertion Sort
6.  Merge Sort
7.  Heap Sort (Binary Heap)
8.  Quick Sort
9.  Topological Sort

# MAKING CODE EFFICIENT

Every problem can be solved in various ways. So how do we analyze and select the best solution to a problem? Here is where time and space complexity plays an important role. The time complexity of an algorithm determines the amount of time taken by an algorithm to run. Similarly, the Space complexity of an algorithm specifies the amount of space or memory taken by an algorithm to run.

Understanding the Big-O Notation helps understand us this quantitative measure in a much better way. Here are a few O notations to understand time complexity better. Imagine a class of n students and give a coin to one person randomly. The task is to find who has the coin.

1.  O(1) — It has been found that the coin is with one among 8 students in the classroom. Going and asking individually will consist of 8 questions. Since the number is a constant, the time complexity is O(1).
2.  O(n) — To find who among the entire class of n students has the coin, going and asking them individually is O(n).
3.  O(n.logn) — Divide the class into two groups, then ask: “Is it on the left side, or the right side of the classroom?” Then divide it into two and ask again, and so on. Repeat the process till you are left with one student who has the coin. This is what you mean by O(log n).
4.  O(n²) — You go and ask the first person of the class, if they have the coin and if they know who among the others have a coin. This is what we call O(n²).

Each assignment statement, return statement is counted as 1 unit. Find the cost of each statement, the repetition and then find a total number of units. In the below example, 4n+4 = O(n).

![](https://miro.medium.com/max/1024/1*_ShhFO-KkyhiyYxom34vYA.png)

Source: BTechSmartClass

The following table consists of the complexities of the common data structures and algorithms.

![](https://miro.medium.com/max/1400/1*Z1ssvqTKv0AXAvGXaNKAPQ.png)

Source: HackerEarth

The precedence of time complexity is as follows:

![](https://miro.medium.com/max/1050/1*cj1VWiv7mdIZqItIV5C9Cg.png)

Source: CSharpCorner
